var A = 42;

var buf[100] = 0;

// Fibo function using memoisation with a given buffer
fibo_mem(buffer, size) {
  let y = 2;
  buffer[0] = 0;
  buffer[1] = 1;

  while y != size {
    buffer[y] = buffer[y-1] + buffer[y-2];
    y = y + 1;
  }
}

// Integer mltiplication
mult(x, y) {
  let acc = 0;

  while x && y {
    if y & 1 {
      acc = acc + x;
    }

    x = x << 1;
    y = y >> 1;
  }

  return acc;
}

// Recursive factorial function
factorial(x) {
  if x == 0 {
    return 1;
  } else {
    return mult(x, factorial(x-1));
  }
}

// Loop based factorial function
loop_factorial(x) {
  let acc = 1;
  let i = 1;

  while i <= x {
    acc = mult(acc, i);
    i = i + 1;
  }

  return acc;
}

// Factorial intermediate function using tail calls
tail_factorial_aux(acc, x) {
  if x == 0 {
    return acc;
  } else {
    return tail_factorial_aux(mult(x, acc), x-1);
  }
}

// Factorial using tail calls
tail_factorial(x) {
  return tail_factorial_aux(1, x);
}

// Fibonachi function using recursive calls
fibo(x) {
  if (x == 0) | (x == 1) {
    return x;
  } else {
    return fibo(x-1) + fibo(x-2);
  }
}

var hello_world = "hello world\n";

swap(a, b) {
  let tmp = *a;
  *a = *b;
  *b = tmp;
}

partition(arr, low, high) {
  let p = arr[low];
  let i = low;
  let j = high;

  while i < j {
    while arr[i] <= p && i <= high - 1 {
      i = i + 1;
    }

    while arr[j] > p && j >= low + 1 {
      j = j - 1;
    }

    if i < j { swap(&arr[i], &arr[j]); }
  }

  swap(&arr[low], &arr[j]);
  return j;
}

quickSort(arr, low, high) {
    if low < high {

        // call partition function to find Partition Index
        let pi = partition(arr, low, high);

        // Recursively call quickSort() for left and right
        // half based on Partition Index
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

var stack[100] = 0;
var memory[100] = 0;

var program = "
    ++++++++++
    [>+++++++>++++++++++>+++>+<<<<-]
    >++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
";

puts(str) {
  let i = 0;

  while str[i] != 0 {
    put_char(str[i]);
    i = i + 1;
  }
}

exit_loop(prog, pos) {
  let count = 0;
  let result = 0;

  while 1 {
    if prog[pos] == '[' {
      count = count + 1;
    }

    if prog[pos] == ']' {
      if count == 1 {
        return pos + 1;
      } else {
        count = count - 1;
      }
    }

    pos = pos + 1;
  }
}

execute(prog) {
  let index = 0;
  let pos = 0;
  let top = 0;

  while prog[pos] != 0 {
    let char = prog[pos];

    if char == '+' {
      memory[index] = memory[index] + 1;
    }

    if char == '-' {
      memory[index] = memory[index] - 1;
    }

    if char == '<' {
      index = index - 1;
    }

    if char == '>' {
      index = index + 1;
    }

    if char == '.' {
      put_char(memory[index]);
    }

    if char == '[' {
      if memory[index] == 0 {
        pos = exit_loop(prog, pos);
        continue;
      }

      stack[top] = pos;
      top = top + 1;
    }

    if char == ']' {
      top = top - 1;

      if memory[index] != 0 {
        pos = stack[top];
        continue;
      }
    }

    pos = pos + 1;
  }
}

foo() {
  execute(program);
}

foo2() {
  execute2(program);
}

main() {
  puts(program);
  //let x = 0;
  //let y = 42;
  //swap(&x, &y);
  //print_i32(x);
  fibo_mem(buf, 100);

  print_i32(buf[20]);

  print_i32(fibo(4));

  print_i32(factorial(12));
  print_i32(tail_factorial(12));
  print_i32(loop_factorial(12));

  let buffer[42];

  let x = 0;
  while hello_world[x] != 0 {
    buffer[x] = hello_world[x];
    x = x + 1;
  }

  buffer[x] = 42;
  buffer[x+1] = 0;

  puts(buffer);
  puts(hello_world);

  quickSort(hello_world, 0, 10);
  puts(hello_world);
}
