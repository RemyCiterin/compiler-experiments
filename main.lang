var A = 42;

var buf[100] = 0;

// Fibo function using memoisation with a given buffer
def fibo_mem(buffer, size) {
  let y = 2;
  buffer[0] = 0;
  buffer[1] = 1;

  while y != size {
    buffer[y] = buffer[y-1] + buffer[y-2];
    y = y + 1;
  }
}

// Integer mltiplication
def mult(x, y) {
  let acc = 0;

  while x && y {
    if y & 1 {
      acc = acc + x;
    } else {
      nop;
    }

    x = x << 1;
    y = y >> 1;
  }

  return acc;
}

// Recursive factorial function
def factorial(x) {
  if x == 0 {
    return 1;
  } else {
    return mult(x, factorial(x-1));
  }
}

// Loop based factorial function
def loop_factorial(x) {
  let acc = 1;
  let i = 1;

  while i <= x {
    acc = mult(acc, i);
    i = i + 1;
  }

  return acc;
}

// Factorial intermediate function using tail calls
def tail_factorial_aux(acc, x) {
  if x == 0 {
    return acc;
  } else {
    return tail_factorial_aux(mult(x, acc), x-1);
  }
}

// Factorial using tail calls
def tail_factorial(x) {
  return tail_factorial_aux(1, x);
}

// Fibonachi function using recursive calls
def fibo(x) {
  if (x == 0) | (x == 1) {
    return x;
  } else {
    return fibo(x-1) + fibo(x-2);
  }
}

var hello_world = "hello world\n";

def swap(a, b) {
  let tmp = *a;
  *a = *b;
  *b = tmp;
}

def partition(arr, low, high) {
  let p = arr[low];
  let i = low;
  let j = high;

  while i < j {
    while (arr[i] <= p) && (i <= (high - 1)) {
      i = i + 1;
    }

    while (arr[j] > p) && (j >= (low + 1)) {
      j = j - 1;
    }

    if i < j { swap(&arr[i], &arr[j]); }
    else { nop; }
  }

  swap(&arr[low], &arr[j]);
  return j;
}

def quickSort(arr, low, high) {
    if (low < high) {

        // call partition function to find Partition Index
        let pi = partition(arr, low, high);

        // Recursively call quickSort() for left and right
        // half based on Partition Index
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    } else {nop;}
}

var stack[100] = 0;
var memory[100] = 0;

var program =
  "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.";

var put_char_buf = "?";
def print_char(x) {
  put_char_buf[0] = x;
  puts(put_char_buf);
}

def exit_loop(prog, pos) {
  let count = 0;

  while 1 {
    if prog[pos] == '[' {
      count = count + 1;
    } else {nop;}

    if prog[pos] == ']' {
      if count == 1 {
        return pos + 1;
      } else {
        count = count - 1;
      }
    } else {nop;}

    pos = pos + 1;
  }
}

def execute(prog) {
  puts(prog);
  let index = 0;
  let pos = 0;
  let top = 0;

  while prog[pos] != 0 {
    let char = prog[pos];

    //print_char(char);

    if char == '+' {
      memory[index] = memory[index] + 1;
    } else {nop;}

    if char == '-' {
      memory[index] = memory[index] - 1;
    } else {nop;}

    if char == '<' {
      index = index - 1;
    } else {nop;}

    if char == '>' {
      index = index + 1;
    } else {nop;}

    if char == '.' {
      print_char(memory[index]);
    } else {nop;}

    if char == '[' {
      //print_i32(exit_loop(prog, pos));
      stack[top] = pos;
      top = top + 1;
    } else {nop;}

    if char == ']' {
      top = top - 1;

      if memory[index] != 0 {
        pos = stack[top];
        continue;
      } else {nop;}
    } else {nop;}

    pos = pos + 1;
  }
}


def main() {
  execute(program);
  //let x = 0;
  //let y = 42;
  //swap(&x, &y);
  //print_i32(x);
  fibo_mem(buf, 100);

  print_i32(buf[20]);

  print_i32(fibo(4));

  print_i32(factorial(12));
  print_i32(tail_factorial(12));
  print_i32(loop_factorial(12));

  puts(hello_world);

  quickSort(hello_world, 0, 10);
  puts(hello_world);
}
